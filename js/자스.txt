----------DOM--------------

1. nodelist vs HTMLcollection
2. innerHTML vs textContent
3. dcoument.createElement('div') // 파라미터에 엘리먼트 스트링형식

4. DOM element 삽입 //header = document.queryselector('.header');
header.append, prepend -> 헤더 안에
header.before, after -> 시블링

5. DOM element 삭제
document.queryselcector('.cookie').remove();
message.parentElement.removeChild(message) // cumbersome but 언젠간 쓸모있음

6. element style
엘리먼트.style.backgroundColor = '#11111' // 백그라운드 컬러를 카멜케이스로, 스트링으로 특정 값
엘리먼트.style.width = '120%' // 단위도 같이 써줘야됨

엘리먼트.style.color -> 인라인으로 된 경우만 뽑아냄(css가 아닌 html파일에 들어간 스타일) 
css에 있으면 값 못뽑음

then how? 
getComputedStyle(message).color; // css파일에 있는 값도 뽑아냄

변경하는법?
messaage.style.height = Number.parseFloat(getComputedStyle(message).height) + 40 +'px'; 

css에서 변수에다가 값 넣어놓는 거 있잖아 그거는
setProperty(변수명, 값); // 이걸로 변경 가능

7. element attributes 
//const logo = 다큐먼트.쿼리셀렉터('.클래스이름');
console.log(logo.src); // 하면 값 출력 나옴
src가 스탠드다 프로퍼티라 가능함 디자이너 이딴거하면 안나옴 ㅋㅋ

then 논 스탠다드 프로퍼티 갖고오고싶으면?
console.log(logo.getAttribute('designer'));

프로퍼티 설정
logo.setAttribute(어트리부트 이름, 값);

둘 차이 있음
console.log(logo.src); // 실제값
console.log(logo.getAttribute('src')); // html에 있는 그대로의 값
-> href의 경우 위는 실제 url 아래는 # 문자 그대로 

8. data attribute
html 이미지 엘리먼트 어트리부트에 data-version-number = "3.0" 이라 있었다 하자
이 때 logo라는 변수에 이미지 다큐먼트 쿼리셀렉터 갈긴담에
logo.dataset.versionNumber 콘솔로그 갈기면 3.0나옴
(dataset이랑 카멜케이스에 집중)

9. class
logo.classList.add('a', 'b'); // 여러개 동시에 갈길수있음
logo.classList.remove('a', 'b');
logo.classList.toggle('a'); // 넣었다 뺐다
logo.classList.contains('a'); // 트루펄스 반환



10. 스크롤링 관련
getBoundingClinetRect() // 온갖정보 다나옴
window.pageXOffset;
window.pageYOffset; // 스크롤 pixel값

documnent.documentElement.clientHeight 
documnent.documentElement.clientWidth // 실제 뷰포트 x축 넓이 y축 넓이

스크롤 하는 함수
//s1coords = section1.getBoundingClinetRect();
window.scrollTo(s1coords.left, s1coords.top); // left랑 top에 집중!
--> 이렇게 하면 오류남 get바운딩클라렉 어쩌구 함수에서 left랑 top은 뷰포트 기준임 (문서시작부터가아녀)
근데 스크롤 투는 문서시작부터 기준값 줘야됨

then how?
window.scrollTo(s1coords.left + window.pageXOffset, s1coords.top+window.pageYOffset); 
// 그럼 둘의 매개변수가 !!뷰포트부터 떨어진 값 + 스크롤을 얼마나 했냐 = 문서부터 얼마나 떨어졌냐!!

여기다 스무스효과도 넣고싶어 then how?
window.scrollTo({
   left: s1coords.left + window.pageXOffset, 
   top: s1coords.top+window.pageYOffset,
   behavior : 'smooth',
})
// 행동이랑 객체가 파라미터인거에 집중!


근데 이것말고 현대적인 방법 ㅋㅋㅋㅋㅋ
section1.scrollIntoView({behavior : 'smooth'});
// 섹션 자체에 함수 붙인걸 집중

11. 이벤트

mouseenter : 마우스가 엘리멘트에 hover되면 발생

이벤트 리스너 추가하는법
a) addEventListner // 이거 쓰세요 지울 수 있다는 장점
b) h1.onmouseenter = functione(e){}; // on+이벤트명 //oldschool

그렇다면 어떻게 지우냐?
이름있는 펑션으로 함수 선언하고
h1.removeEventListener('mouseenter', 함수이름)

html에서도 <h1 onclick = "alert('안녕')"> 이런식으로 이벤트 추가할 수 있는데 쓰지마셈

CAPTURING & BUBBLING

맨처음 targetElement에 이벤트 발생시키면
다큐먼트root부터 쭉 내려옴(캡쳐링)
그러고 다시 다큐먼트 root까지 쭉 올라감(버블링)

모두가 이러진 않음 어떤건 타겟에서만 발생함

부모엘리멘트에도 이벤트리스너를 두면 (낚아채는 느낌이지)
그럼 타겟 엘리멘트에 이벤트 발생시켜도 부모들도 다 
이벤트리스너가 작동하지 근데 부모에 작동시키면 자식은 발동안하자ㅣ 

근데 이때도 e.target은 자식인걸 다 알고 있어
e.currentTarget은 이벤트를 낚아챈 엘리멘트를 뽑아줘 그니까 자식에서 버블링 돼서 올라온거면 자기 자신을 출력한다고
근데 이벤트리스너에서 this는 이벤트리스너를 붙인 엘리멘트니까
e.currentTarget은 this랑 같은거지

이런 이벤트 propagation을 막는 방법은
e.stopPropagation() 함수 이럼 버블링 안됨
근데 별로 안쓰여 웬만해선 제발 쓰지마

캡쳐링에선 안낚아챔 버블링 페이스에서만 낚아냄
만약 캡쳐링에서 낚아채게 하고싶으면
eventListener함수 세번째 파라미터로 true로 바꾸면 버블링에선 안낚고 캡쳐링에서 낚음



그럼 이걸로 뭐하자고? 구현 패턴이 있음
이벤트 propagation(bubbling)을 이용한 이벤트 delegation
또는 아직 존재하지 않는 엘리멘트에 이벤트 리스너 넣고 싶을때!!

각각에 foreach로 addEventListner 넣지 말자
then how? 
1. 공통 부모에다가 이벤트리스너 추가
2. 어떤애가 e.target이었는지 판별할것!

12. DOM TRAVERSING

자식 트래벌싱
엘리먼트에 대해 queryselector(All) 갈기면 꼭 직계자식이 아니라 얼마나 deep한지에 상관없이 다 가져옴
h1.childNodes // 하위에 있는 모든 노드들 ㅋㅋ 잡다한것도 있자나 
복습할 때 노드랑 엘리먼트 차이점 공부해
근데 직계자식만 갖고싶어? 그럼 
h1.children
h1.firstElementChild는 첫번째 자식만
h1.lastElementChild는 첫번째 자식만

부모 트래벌싱
h1.parentNode // 
h1.parentElement // 부모인경우는 위에랑 똑같음

근데 직계말고 조상중에 하나 찾고싶으면
h1.closest() // 자기자신도 포함!!!!!!!!!!!! null값을 return할수도있음!!!!!!!!

형제 트래벌싱
h1.previousElementSibling 바로앞의 시블링
h1.nextElementsSibling 바로뒤의 시블링
바로 앞뒤만 찾잖아 그럼 다 찾고 싶을땐?
부모로 가서 
h1.parentElement.children

13. Tabbed component

guard clause : closest와 같이 null을 리턴할경우 그 즉시 펑션에서 리턴!

위로 덮는게 아니라 클래스 제거해서 엘리먼트 자체를 없애고 해당 엘리먼트를 다시 붙이는거임
그래서 탭하면 마치 보이는 것처럼!

14. Passing arguments in event handler!

mouseenter vs mouseover
mouseEnter는 버블(프로퍼게이트)이 없음!!!

탭은 자식 엘리먼트가 있어서 closest메소드를 썼는데 링크는 자기자신이 가장 자식인지라
closest할 필요없이 바로 e.target갈기면 됨!

부모에 이벤트 델리게이션 사용한거니까 부모에 이벤트리스너 추가하고
안에서 if(e.target.classList.contains('원하는클래스')) 로 매칭!

암튼 어떻게 argument를 이벤트핸들러에서 전달하냐?
이벤트리스너에 그냥 함수 명만 띡 적어줘서 파라미터를 못주잖아 // 함수자체를 실행하면 결과값이 리턴되겠지? 그리고 e도 뭔지도모르고
그럼 걍 익명 함수에다가 거기서 다시! 밖에 빼놓은 함수를 실행시키는거임.
근데 이거 구림
then how? 
bind method!!!! (bind랑 this복습하기)
bind는 또다른 함수 return, 이벤트리스너 this는 e.target 어쩌구..


15. Scroll event

window.scrollY값은 페이지 시작부터 뷰포트 최상단이 얼마나 떨어졌는 지를 나타냄
== window.pageYOffset

성능에 ㅈㄴ안좋음 쓰지마셈
대신 밑에거 쓰셈!

16. Intersection Observer API (스티키 네비게이션 구현)

const obsCallback = function (entries, observer) {}; // entries는 스레시홀드 배열로 선언할 수도 있음
						옵저버는 객체 자체가 전달되는거

const obsOptions = {
  root: null, 			// root는 observe 할 엘리먼트랑 인터섹팅할 엘리먼트인데 
					null로 설정하면 뷰포트랑 옵저빙하는 엘리먼트 인터섹팅관찰
  threshold: 0.1,			// 콜백함수를 몇퍼일때 부를거냐~ 
					배열로 선언하면 가장 작은 값만큼만 겹쳐도 isIntersecting은 항상 true
  rootMargin: `-${nav.getBoundingClientRect().height}px`		
				// 말그대로 루트의 마진 뷰포인트인 경우는 뷰포인트랑 인터섹팅
				   하는 곳의 -90픽셀에서 스티키 바 딱!
};

const observer = new IntersectionObserver(옵션객체, 콜백함수);
observer.observe(엘리먼트);

17. 와 시발 Intersection Observer API 이걸로 애플같이 구현할 수 있음;
이건 강의로직 따라서..

18. lazy loading
위랑 마찬가지로 강의로직.. 근데 css가 더 중요하다 느낌

굳이 사용자한테 안보여주고싶으면 조금 먼저 로딩 시작시키면 됨

19. slider
꽤 어려움 강의 로직 확인


20 . 로딩
html 파싱이랑 돔트리 : 
document.addEventListner('DOMContentLoaded', fucntion(e){});

외부적인 리소스들까지 싹다 :
window.addEventListener('load', functione(e){});

로딩 이전에 :
window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  console.log(e);
  e.returnValue = '';
});
이 사이트에서 나가겠습니까?


async vs defer
defer in head! 가 승리자!
nothing in body는 모든 브라우저를 지원해야 할 때








ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
러닝자바스크립트
6장 함수

단순 문법
const obj = {
    name : 'park',
    bark : function(){ return `my name is ${this.name} }
}

const obj = {
    name : 'park',
    bark() { return `my name is ${this.name} }
    barkChoision = (el) => {}
}



this는 함수의 선언이 중요한게 아니라 어떻게 호출했느냐에 따라 결정
const bark = obj.bark
bark === obj.bark // true
bark(); // my name is undefined



중첩된 함수 안에서 this
객체내의 함수에서 다시 함수를 호출하면 this는 객체를 가르키지 않음
solution // const self = this
러닝자바스크립트 p.178참조
solution2 // arrow function
p.182 참조 why??????? -> 유데미에서 this 총정리 함 듣기



함수 선언
function f() {

	    }
익명함수 
function() {

   	 }


arguments : 함수내에서 사용할 수 있는 객체, Array아니지만 비슷함


call,apply,bind

func.call(obj, arg1, arg2, ...)
apply는 완전히 동일 다만 
func.apply(obj, [arg1,arg2]) 배열을 받음
따라서
func.call(obj,...arr)로 완전히 대체 가능

bind는 영구고정
func.bind(obj)하면 죽을때까지 고정
func.bind(obj, arg1) 이것도 죽을때까지 고정


7장 스코프


lexical scope란??? 정적 스코프란???

var는 호이스팅 되지만 선언만 끌어올려짐, 할당은 끌어올려지지 않음
변수 가리기(masking)도 불가능함.

함수역시도 선언은 호이스팅됨 -> 함수 선언하기 전에 호출 가능
f();
function f() {
      console.log('hoisting!');
}

but 변수에 할당된 함수 표현식은 호이스팅 되지 않음 -> 변수 스코프 규칙 그대로 따름 -> 함수 표현식 전 
호출 불가능
f();
let f = function() {
      console.log('not hoisting!');
}


what is 스트릭트 모드?
ES5에는 암시적 전역변수 존재 
암시적 전역변수란? var로 선언하지 않은 변수 -> 새로 만들어 버림
스트릭트 모드는 암시적 전역변수를 허용하지 않음



ㅡ
동기 비동기

동기 : 다음 코드가 이전 코드의 실행이 끝나기를 기다린다고 이해할 수 있음(-> block이 된다고 이해)
비동기: 다음 코드는 이전 코드의 실행이 끝나지 않아도 진행됨(-> non blocking)

ajax call : asynchronous javascript and xml.  대표적인 비동기. request data from web servers dynamically 
(xml : json이전의 데이터 format. 이젠 아무도 안씀)
api : 어플리케이션 프로그래밍 인터페이스 . 제네럴한 용어 
json: data format -> 객체를 스트링화한 형식




request = new XMLHttpRequest();
request.open( 'GET',  url );
request.send();
request.addEventListener('load', function () {const data = JSON.parse(this.responseText)});
이벤트 리스너안에 또 비슷한 작업을 해야되면 콜백헬 발생

-> promise로 콜백헬 탈출!
fetch 함수는 promise 사용해서 콜백헬로부터 자유롭다


그럼 promise는 뭘까?
딱딱하게 말하면 An object that is used as a placeholder for the future result of an asynchronous operation.
조금 루즈하게 말하면 A container for an asynchronously delivered value
더더욱 루즈하게 말하면 A container for a future value

promise의 라이프 사이클
pending settled
pending: before the future value is available
settled: asynchronous task has finished

settled는 다시 두개로 나뉨 fulfilled rejected
한번 settled되고 나서 fulfilled나 rejected 상태를 변경할 수는 없음

build promise -> consume promise 
promise build하는 것보다 consume하는게 더 쉽다! consume하는 법을 먼저 보자


promise가 settled(fulfilled) 되고나면 .then()을 이용할 수 있음
