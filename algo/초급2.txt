초급2
------------------------------------
cstring
int d[100][100];
memset(d, -1 ,sizeof(d)) // d의 원소들 싹 다 -1로 만듦

cstdio
scanf("%1d", &a); //입력이 123이렇게 띄어쓰기 없이 연속으로 와도 한자리씩 넣을수있음
scanf("%1d", &arr[i][j]); // 배열도 엔퍼센트 붙임..

// 이건 문자열 abcd일때 하나씩 입력받는 방법임
char arr[50][50];
for (int i = 0; i < n; i++) {
     cin >> arr[i];
}


algorithm
sort(arr, arr+n);  // 부분적으로 정렬도 가능함 arr+i는 index를 나타냄, n은 i+1 
swap(a,b);
min(a,b);
max(a,b);
next_permutation(v.begin(), v.end()) // 다음 순열 구하는 함수, 직접 함수 만들줄 알아야함

minmax_element
    int Numbers[10] = { 50, 25, 20, 7, 15, 7, 10, 2, 1, 3 };
    pair<int*, int*> MinMaxValue = minmax_element( &Numbers[0], &Numbers[10] );
    cout << "최소 값 : " << *MinMaxValue.first << endl;
    cout << "최대 값 : " << *MinMaxValue.second << endl;

    auto p = minmax_element(list.begin(), list.end());
    cout << *p.second << '\n';
    cout << *p.first;



string
to_string(i); // i를 string으로 바꿔줌
i+'0'; // i를 char로 바꿔줌
char1 > char2 는 비교가능함! char1이 뒤에 나오는 알파벳이면 true (예를들어 char1이 B고 char2가 A)
(또는 char1이 '2'이고 char2가 '1') 

vector
v.size() 벡터의 길이를 알려주는 연산
vector<int> vec(n) // n개의 원소를 0으로 초기화한 vector 

pair
pair<int, int> R;
R = { 3,4 };
cout << R.first;

queue
queue<int> q;
int a = q.front(); q.pop();
------------------------------------

<브루트포스>

규칙성 찾기 : 최대의 규칙성을 찾았으면 -> 컴퓨터한테 규칙적인 부분만 연산 시키면 됨
정수론 문제 아이디어 : 몇의 세계에서만 숫자가 돈다. -> 규칙성 찾기 좀 쉬워지지

재귀함수 : 
1. 다중 포문인데 동적으로 n중 포문을 할당할 수 있다고 해야되나
2. 완전탐색 즉 !!!!브루트포스!!!에 겁나 적합함. 그리고 가져가야 되는 값을 함수 파라미터로 전달하는 스킬
3. 팩토리얼인 경우 vs 2^n으로 선택하는 경우 두가지 경우의 수! 

<백트랙킹>
그냥 완탐인데.. 음 종료조건을 미리 걸어놓는거임

 

3085 사탕게임
1107 리모컨

21.07.03 5문제 ㅇㅋ
14500 테트로미노 : 구현 문제였는데 음.. 단순하다 근데 치기가 귀찮았어 이런걸 왜 낸거지
6064 카잉달력 : !!!다시풀기 애초에 발상을 못함.  // 정수론 부분
1748 수 이어 쓰기 : !!!다시풀기 니가 생각하는걸 구현해.. 
15649 N과 M1 : !!!다시풀기 재귀.. 거의 흉내냄 // 예외처리도 하나 있다
15650 N과 M2 : 1풀었으면 2도 무조건 풀 수 있음
N과 M2 다른 풀이도 있음..

21.07.05 
N과 M 3~8 : 그냥 재귀함수 그 자체
15663 N과 M 9 : !!! 죽어도 다시풀기. 중복을 처리하는 아이디어
N과 M 10~12 : 9를 알면 모든게 다 풀려 
10972 다음 순열: !!! 다시풀기, next_permutation 직접 구현하는 문제.
이전순열
모든순열

21.07.08 
10819 최대차 : 순열, 시간복잡도
10971 외판원 : !!! 다시풀기, 니가 좋아하는 수학적 아이디어 && 팩토리얼 한개 줄일 수 있음
6603 로또 : !!! 다시풀기 너무 좋은 문제 순열로 선택하는 아이디어 그리고 사고의 집요함!

21.07.09
9095 123더하기 : !!! 다시풀기 DP랑 재귀 기본.. 둘로 다 풀수있어야됨.
1759 암호 : !!! 음.. 재귀 골드5 문젠데 원칙은 다 똑같다. 다시 츄라이 하고싶음 해봐. 
	   ㄴㄴ 퇴사 풀고나니까 시간복잡도가 잘못됐음 운좋아서 맞은거.. 
14501 퇴사 : !!! 무조건 다시풀기. 재귀의 또다른 사용법. 솔직히 문제 좆같은데 니가 이걸 훈련해야 사고력이 늘어난다.
	     사고의 집요함, 언어적 트릭, 재귀 또다른 사용법도 브루트포스함.. 고려할거 많음
14889 스타트와링크 : !!! 다른사람아이디어 빌렸음..다시풀기 & 백준 풀이법이랑 비교해보기. 
15661 링크와스타트 : 14889 풀면 풀 수 있음

21.08.13
2529 부등호 : 로직은 맞았는데 c++ 문법을 몰라서 시간을 많이 뺏긴 문제, string이랑 vector사용법
1248 맞춰봐 : !!! 답지보고도 못푼문제.. 
11723 비트마스크: 비트마스크 기본개념, 나중에 다시 풀람 풀고 안풀어도됨
1182 부분수열의 합: 완탐으론 풀었는데, 비트마스킹으로 어케풀지? 
		  !!!비트마스킹으로 푸는 방법은 알아냄 근데 로직이 자연스럽지 못해 다시풀기!
14889 스타트와 링크: !!!비트마스크로 풀어보기, 음.. 비트를 인덱스로 사용하기!
14391 종이조각: !!!다시풀기 아예 혼자 못품! 다 답지보고품!


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


DP는 뭐가 중요했는지 기억안난다...
브루트포스는 시간복잡도 계산부터 먼저!!
완탐인데 시간복잡도가 초과? 백트랙킹
비트마스킹은 입력값이 확실히 정해져있어야됨 why? 비트수를 그래야 정하잖아

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
그래프
인접행렬vs인접 리스트
무적권 인접리스트 활용! 인접행렬 안씀
!!!두개 시간복잡도 나중에 공부하기

간선리스트
인접리스트를 써야되는데 라이브러리 사용금지될경우

DFS, BFS 목적 : 임의의 정점에서 시작(시작점 꼭 존재), 연결되어 있는 모든 정점을 1번씩 방문하는 것
DFS : 깊이우선탐색 -> 일단 갈 수 있는데 다 가보고 안되면 돌아오기 stack 사실 스택으로 구현할일은 없음
걍 재귀로 구현하기
O(v^2):인접행렬 //  O(V+E) :인접리스트 -> E가 보통 더 크기 때문에 O(E) 그니깐 인접리스트 쓰기


BFS: 너비우선탐색 -> 한 곳에서 갈 수 있는데 다 가보기 queue
그래프중에 젤 중요함
큐에 넣을때 방문했다고 체크해야됨
O(v^2):인접행렬 //  O(V+E) :인접리스트 -> E가 보통 더 크기 때문에 O(E) 그니깐 인접리스트 쓰기!






13023 ABCDE : 다시 풀어보기, 인접행렬,인접리스트,간선리스트 활용해서 탐색을 색다르게 할 수도 있고
	        기본적으로 그래프 어떻게 만드는지 알 수 있는 문제
1250 DFS와 BFS: 다시풀기, DFS BFS 기본 대표문제!!!
11724 연결요소: dfs bfs 연결요소 뜻만 알면 풀수있는 문제..
1707 이분탐색:  !!!다시풀기 이분탐색정의랑.. 솔직히 불리언대신 숫자하나 더 쓴다 
		이거 생각하나땜에 골드인가 했는데~ 연결요소적인 생각도 해야됨
2667 단지붙이기: !!! 다시풀기 혼자서 풀면 아마 못풀수도 있음. DFS의 고정관념을 깨준문제
4963 미로찾기: 간만에 쉬운문제~
2178: 미로탐색: !!! 여러번 다시풀어야겠다. bfs가 최소거리를 찾는 알고리즘인거랑.. 암튼 다시 풀어보기
7576: 토마토: bfs까지는 이해했다. 근데 1이 여러개에서 출발할 때 어떻게 check를 표시하지?
                   !!! -> bfs에서 큐에 동시에(한 포문에서) 들어간 놈들은 동시로 취급하는거임 순서 상관없음..
7562 나이트의 이동: 음 위에문제들 풀고나니까 쉬웠어 

16929 투닷 : !!! 답지보고도 잘 이해못함 다시풀기 
		1. 재귀함수에서 return값이 bool인 경우를 이해를 잘 못했음
		2. 위와같이 리턴값이 있을때 로직짜는게 좀 힘들었음

16947 서울 지하철 2호선 : !!! 아예 못품 답지도 이해못함
			-> 답지 이해함 근데 개 레전드인게 순환선이 없을 수가 있는가?
			-> 정점의 개수랑 간선 개수 같음 -> 사이클 1개 무조건 생김
			-> why? 정점개수-1개의 간선으로 트리를 만들 수 있는데 여기다 간선 하나 추가하면 무조건 사이클 생성
			어쨌든 다시 풀기 

dfs에서 return값..있는게 좀 힘들다

16940 bfs 스페셜저지 : !!! 다시풀기 내가 풀었던 방법(그냥 단순 숫자 비교 왜 안되는지 생각해보셈 큐잖아
			순서가 동일해야대!!)
			답지에서 불필요한 코드가 있음 왜넣었는지 모르겠다..
			그래도 무조건 다시풀어 큐의 성질을 이해하자
			그리고 include함수 만들어서 할라 했었는데 그걸 하나로 퉁칠 수 있는게 parent 배열

16964 dfs 스페셜저지 : !!! 
2146 다리 만들기: !!! 다시풀기 아이디어가 좋아
1697 숨바꼭질: 이 문제를 보고 어떻게 바로 bfs를 생각할 수 있지?
13913 숨바꼭질4 : 위에 문제 풀줄 알면 바로 풀림
14226 이모티콘: !!! ?? 답지보고도 긴가민가해 이게 왜 bfs를 떠올리게하지? 
13549 숨바꼭질3 : !!! 강의 해설 듣고 욕나올정도로 놀람. 
		아이디어 짱인 문제 -> 큐를 두개써야되는데 -> 덱 한개로..
1261 알고스팟: !!! 이문제도 같은 아이디언데 와 진짜 큐라는 특성을.. 미쳤다


트리는 사이클이 없는 연결 그래프
트리는 루트가 있을 수도 있다 없을 수도 있다 루트는 정하기 나름이다 : 제일 중요한 부분
트리는 그래프처럼 사용해야됨 but 루트가 있다면
1. 부모만 저장하는 방식 -> 유니온 파인드
2. 완전 이진 트리의 경우는 배열로 표현하게 됨 -> 힙, 세그먼트 트리

트리 순회
dfs, bfs
dfs같은 경우는 프리오더 인오더 포스트오더 노드방문 처리를 언제할거냐 기준

프리오더는 그냥 일반적인 dfs
인오더는 bst에서 삭제구현할때만 씀 잘 안씀 -> 이진트리 아니면 못써먹음 :
포스트오더를 제일 많이씀  대부분의 트리는 포스트오더!!!


1991 트리순회 : !!!트리 기본문제 푸는데 3분도 안걸림 
11725 트리의 부모찾기: so easy,, but bfs로 푼것도 있다하니 내코드랑 비교해보기
2250 트리의 높이와 너비: !!! 인오더의 정점.. 아이디어 짱인문제..
1167 트리의 지름: !!! ???이게 왜됨? 걍 bfs두번돌리는건데 외워서 하는 알고리즘 원리 한번 알아보기